### 概览

​	UI 界面在开发中是极其重要的一部分，几乎所有的 UI 界面都是用 View 来描述的。作为 UI 的描述，就少不了与用户交互的逻辑和动画，而这些就需要使用 View 来实现。一般情况下是从 xml 中添加 View，不过也可以从代码中添加，但要比 xml 麻烦些，不过灵活性就大大增加了。

#### 目录

- [View 树](#View 树)
  - [View、ViewGroup 和 ViewParent](#View、ViewGroup 和 ViewParent)
  - [View 框架](#View 框架)
  - [创建过程](#创建过程)
    - View 树在 Activity 中的创建过程
    - View 树在 Dialog 中的创建过程
  - [遍历时机](#遍历时机)
  - [遍历流程](#遍历流程)
    - 测量
    - 布局
    - 绘制
    - 在 View 树中添加和删除 View
- View 的事件分发
- View 动画

***

- ##### View 树

  在 xml 写布局的时候，里面的元素都形成了树状结构的关系。对于一个界面就是一颗 View 树，我们在使用 findViewById() 时，就是深度优先遍历去找 View 的实例。
  
  - ###### View、ViewGroup 和 ViewParent
  
    先以一个 UML 图介绍它们之间的联系：
  
    ![](http://chuantu.xyz/t6/714/1580691912x989559058.jpg)
  
    ViewGroup 为 View 的子类，且实现了 ViewParent。以 UML 图的视角来看是这么回事。如果从 xml 来看 ViewGroup 是 View 的父布局，ViewGroup 也可以是 ViewGroup 的父布局。
  
    ![View 树](https://developer.android.google.cn/images/viewgroup_2x.png)
  
    结合上面所述，在布局中，View 树的叶子结点一定是 View 类或其子类 ViewGroup（因为 ViewGroup 也算是 View），其余都是 ViewGroup。ViewParent 的作用是提供了子布局的 View 或其子类 ViewGroup 与父布局交互的接口。
  
    ```Java
    //--- SDK 29 ---
    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P)
    protected ViewParent mParent;
    ```
  
  - ###### View 框架
  
    ![](http://chuantu.xyz/t6/715/1581172873x2728309358.png)
  
    以 Activity 为例，众所周知 Activity 支持 UI 显示，但它并没有直接管理 View 树。它持有一个实例 Window，它是抽象类且只有一个唯一的实现类 PhoneWindow。Window 可看作是 UI 界面的外框，里面的内容和布局由它来规划，Activity 不需要关心它具体是怎么规划的。
  
    一个应用程序可能存在多个 Window，由此就需要 WindowManager 来统一进行管理。WindowManager 是个接口，它继承于 ViewManager，ViewManager 也是接口，只不过它们两的职能不一样。放一下 Google 对它们的介绍：
  
    ```java
    //---ViewManager---
    /**
     * Interface to let you add and remove child views to an Activity. 
     * 用于添加和删除 Activity 的子视图的接口。
     */
    //---WindowManager---
    /**
     * The interface that apps use to talk to the window manager.
     * 应用程序与 WindowManager 交互的接口。
     */
    ```
  
    WindowManagerImpl 是 WindowManager 唯一实现类，每一个进程仅只有一个 WindowManagerImpl 实例。需要注意它持有一个叫 WindowManagerGlobal 类的实例，WindowManagerGlobal 为 WindowManagerImpl 提供了与系统的 WindowManager 的通信，它以单例的形式存在于内存当中。
  
    ```java
    private WindowManagerGlobal() {
    }
    
    @UnsupportedAppUsage
    private static WindowManagerGlobal sDefaultWindowManager;
    
    @UnsupportedAppUsage
    public static WindowManagerGlobal getInstance() {
        synchronized (WindowManagerGlobal.class) {
            if (sDefaultWindowManager == null) {
                sDefaultWindowManager = new WindowManagerGlobal();
            }
            return sDefaultWindowManager;
        }
    }
    ```
  
    它里面有三个数组用来记录应用程序每个 View 树的根、窗口属性以及一个叫 ViewRootImpl 的类。这里事先说一下，WindowManagerGlobal 内部会有一个叫 IWindowSession 的属性，目前只需要知道它被用来和 WindowManagerService 通信即可，不用深入了解。ViewRootImpl 主要做的就是利用这个 IWindowSession 和 WindowManagerService 通信，因为新增一棵 View 树对于 WindowManagerService 相当于新增一个 Window，需要通知 WindowManagerService 并向它注册。
  
    ```java
    //ViewRootImpl
    @UnsupportedAppUsage
    final IWindowSession mWindowSession;
    
    public ViewRootImpl(Context context, Display display) {
        ...
    	mWindowSession = WindowManagerGlobal.getWindowSession();
        ...
    }
    //WindowManagerGlobal
    @UnsupportedAppUsage
    private static IWindowSession sWindowSession;
    
    @UnsupportedAppUsage
    public static IWindowSession getWindowSession() {
        synchronized (WindowManagerGlobal.class) {
            if (sWindowSession == null) {
                try {
                    ...
                    IWindowManager windowManager = getWindowManagerService();
                    sWindowSession = windowManager.openSession(
                            new IWindowSessionCallback.Stub() {
                                @Override
                                public void onAnimatorScaleChanged(float scale) {
                                    ValueAnimator.setDurationScale(scale);
                                }
                            });
                } catch (RemoteException e) {
                    throw e.rethrowFromSystemServer();
                }
            }
            return sWindowSession;
        }
    }
    ```
  
    > ※ WindowManagerService 是系统的窗口管理器，添加窗口必须要和它通信，并且它还负责各种事件的派发。
  
  - ###### 创建过程
  
    - [View 树在 Activity 中的创建过程](https://github.com/MemoryLimitExceeded/Android/blob/master/%E7%9F%A5%E8%AF%86%E7%82%B9/readme%E8%AF%A6%E7%BB%86%E5%86%85%E5%AE%B9/Android/UI/View%20%E4%BD%93%E7%B3%BB/View%20%E6%A0%91%E5%9C%A8%20Activity%20%E4%B8%AD%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.md)
  
      View 树的创建是由 Activity 的 onCreate() 中的 setContentView(Int) 发起的。
  
      > ※ setContentView() 有三个重载方法，效果都差不多，只是传入的参数不同。如果不清楚 Activity 的 onCreate() 是什么的话请参阅 Activity [概览](https://github.com/MemoryLimitExceeded/Android/blob/master/%E7%9F%A5%E8%AF%86%E7%82%B9/readme%E8%AF%A6%E7%BB%86%E5%86%85%E5%AE%B9/Android/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/Activity/%E6%A6%82%E8%A7%88.md)的生命周期那一节。
  
      Activity 调用 getWindow().setContentView() 在 Window 生成一个叫 DecorView 的实例，做为 View 树的根 View，它继承于  FrameLayout，而 FrameLayout 又继承于 ViewGroup。 随后将 Activity.setContentView(Int) 传入的布局文件 Id ，解析 xml 并将这个布局添加到内容中（contentParent）。
  
      ![](https://upload-images.jianshu.io/upload_images/7522223-68eef8da18fe8dce.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)
  
      > ※ 上图中的 Action Bar 在 Android 5.0 的时候被替换成了 Tool Bar，且只有 AppCompatActivity 有，其他都需要自己添加。不过可以调用 setTitle() 来用 TextView 显示标题。
  
      在 Activity 恢复到前台的时候 WindowManager 会调用 addView() 方法来进行 View 树的遍历，
  
      到最后将调用 ViewRootImpl.setView() 方法，开始遍历 View 树。
  
    - View 树在 Dialog 中的创建过程
  
      它和 Activity 是一样的，都是调用 Window.setContentView()，来生成 View 树，由 Dialog.show() 发起。
  
  - ###### 遍历时机
  
  - ###### 遍历流程
  
    - [在 View 树中添加和删除 View](https://github.com/MemoryLimitExceeded/Android/blob/master/%E7%9F%A5%E8%AF%86%E7%82%B9/readme%E8%AF%A6%E7%BB%86%E5%86%85%E5%AE%B9/Android/UI/View%20%E4%BD%93%E7%B3%BB/%E5%9C%A8%20View%20%E6%A0%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%20View.md)
  
      - 添加 View
    
        通过调用 ViewGroup.addView() 来实现把新创建的 View 添加到 View 树中。一共有 5 个调用方法：
    
        ```java
        public void addView(View child) {
            addView(child, -1);
        }
        public void addView(View child, int index) {
            ...
            addView(child, index, params);
        }
        public void addView(View child, int width, int height) {
            ...
            addView(child, -1, params);
        }
        public void addView(View child, LayoutParams params) {
            addView(child, -1, params);
        }
        public void addView(View child, int index, LayoutParams params) {
            ...
            requestLayout();
            invalidate(true);
            addViewInner(child, index, params, false);
        }
        ```
    
        前 4 个方法最终都会调用最后一个方法，其中第 4 个方法是实现了 ViewManager 接口的方法。ViewManager 就是专门添加和删除 View 的接口。
    
        ```java
        Interface to let you add and remove child views to an Activity（个人认为只要有类似 Activity 的 View 树就能使用这个接口，例如 Dialog）. To get an instance of this class, call {@link android.content.Context#getSystemService(java.lang.String) Context.getSystemService()}.
        ```
    
        然后真正添加到 View 树的是调用了 addViewInner()。
    
        > ※ requestLayout() 将会重新遍历 View 树，遍历完成整个 View 树的绘制流程，而 invalidate() 虽然会重新遍历 View 树，但只会进行重绘这一步骤，测量和定位不会执行。
    
      - 删除 View
    
        有以下方法来实现把 View 从 View 树中删除：
    
        ```java
        public void removeView(View view) {
            if (removeViewInternal(view)) {
                requestLayout();
                invalidate(true);
            }
        }
        public void removeViewInLayout(View view) {
            removeViewInternal(view);
        }
        public void removeViewAt(int index) {
            removeViewInternal(index, getChildAt(index));
            requestLayout();
            invalidate(true);
        }
        public void removeViews(int start, int count) {
            removeViewsInternal(start, count);
            requestLayout();
            invalidate(true);
        }
        public void removeViewsInLayout(int start, int count) {
            removeViewsInternal(start, count);
        }
        public void removeAllViews() {
                removeAllViewsInLayout();
                requestLayout();
                invalidate(true);
            }
        protected void removeDetachedView(View child, boolean animate) {
        }
        ```
    
        以上都是通过调用 removeViewsInternal() 间接实现，它有三个重载方法：
    
        ```java
        private boolean removeViewInternal(View view) {
            final int index = indexOfChild(view);
            if (index >= 0) {
                removeViewInternal(index, view);
                return true;
            }
            return false;
        }
        private void removeViewInternal(int index, View view) {
            ...
        }
        private void removeViewsInternal(int start, int count) {
            ...
        }
        ```
    
        
    
    
    
    