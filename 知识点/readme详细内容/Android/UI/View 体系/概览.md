### 概览

​	UI 界面在开发中是极其重要的一部分，几乎所有的 UI 界面都是用 View 来描述的。作为 UI 的描述，就少不了与用户交互的逻辑和动画，而这些就需要使用 View 来实现。一般情况下是从 xml 中添加 View，不过也可以从代码中添加，但要比 xml 麻烦些，不过灵活性就大大增加了。

#### 目录

- [View 树](#View 树)
  - [View、ViewGroup 和 ViewParent](#View、ViewGroup 和 ViewParent)
  - [View 框架](#View 框架)
  - [创建过程](#创建过程)
    - View 树在 Activity 中的创建过程
    - View 树在 Dialog 中的创建过程
  - [遍历时机](#遍历时机)
  - [遍历流程](#遍历流程)
    - 测量
    - 布局
    - 绘制
  - [在 View 树中添加和删除 View](#在 View 树中添加和删除 View)
- View 的事件分发
- View 动画

***

- ##### View 树

  在 xml 写布局的时候，里面的元素都形成了树状结构的关系。对于一个界面就是一颗 View 树，我们在使用 findViewById() 时，就是深度优先遍历去找 View 的实例。
  
  - ###### View、ViewGroup 和 ViewParent
  
    先以一个 UML 图介绍它们之间的联系：
  
    ![](http://chuantu.xyz/t6/714/1580691912x989559058.jpg)
  
    ViewGroup 为 View 的子类，且实现了 ViewParent。以 UML 图的视角来看是这么回事。如果从 xml 来看 ViewGroup 是 View 的父布局，ViewGroup 也可以是 ViewGroup 的父布局。
  
    ![View 树](https://developer.android.google.cn/images/viewgroup_2x.png)
  
    结合上面所述，在布局中，View 树的叶子结点一定是 View 类或其子类 ViewGroup（因为 ViewGroup 也算是 View），其余都是 ViewGroup。ViewParent 的作用是提供了子布局的 View 或其子类 ViewGroup 与父布局交互的接口。
  
    ```Java
    //--- SDK 29 ---
    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P)
    protected ViewParent mParent;
    ```
  
  - ###### View 框架
  
    ![](http://chuantu.xyz/t6/715/1581172873x2728309358.png)
  
    以 Activity 为例，众所周知 Activity 支持 UI 显示，但它并没有直接管理 View 树。它持有一个实例 Window，它是抽象类且只有一个唯一的实现类 PhoneWindow。Window 可看作是 UI 界面的外框，里面的内容和布局由它来规划，Activity 不需要关心它具体是怎么规划的。
  
    一个应用程序可能存在多个 Window，由此就需要 WindowManager 来统一进行管理。WindowManager 是个接口，它继承于 ViewManager，ViewManager 也是接口，只不过它们两的职能不一样。放一下 Google 对它们的介绍：
  
    ```java
    //---ViewManager---
    /**
     * Interface to let you add and remove child views to an Activity. 
     * 用于添加和删除 Activity 的子视图的接口。
     */
    //---WindowManager---
    /**
     * The interface that apps use to talk to the window manager.
     * 应用程序与 WindowManager 交互的接口。
     */
    ```
  
    WindowManagerImpl 是 WindowManager 唯一实现类，每一个进程仅只有一个 WindowManagerImpl 实例。需要注意它持有一个叫 WindowManagerGlobal 类的实例，WindowManagerGlobal 为 WindowManagerImpl 提供了与系统的 WindowManager 的通信，它以单例的形式存在于内存当中。
  
    ```java
    //--- SDK 29 ---
    private WindowManagerGlobal() {
    }
    
    @UnsupportedAppUsage
    private static WindowManagerGlobal sDefaultWindowManager;
    
    @UnsupportedAppUsage
    public static WindowManagerGlobal getInstance() {
        synchronized (WindowManagerGlobal.class) {
            if (sDefaultWindowManager == null) {
                sDefaultWindowManager = new WindowManagerGlobal();
            }
            return sDefaultWindowManager;
        }
    }
    ```
  
    它里面有三个数组用来记录应用程序每个 View 树的根、窗口属性以及一个叫 ViewRootImpl 的类。这里事先说一下，WindowManagerGlobal 内部会有一个叫 IWindowSession 的属性，目前只需要知道它被用来和 WindowManagerService 通信即可，不用深入了解。ViewRootImpl 主要做的就是利用这个 IWindowSession 和 WindowManagerService 通信，因为新增一棵 View 树对于 WindowManagerService 相当于新增一个 Window，需要通知 WindowManagerService 并向它注册。
  
    ```java
    //--- SDK 29 ---
    //ViewRootImpl
    @UnsupportedAppUsage
    final IWindowSession mWindowSession;
    
    public ViewRootImpl(Context context, Display display) {
        ...
    	mWindowSession = WindowManagerGlobal.getWindowSession();
        ...
    }
    //WindowManagerGlobal
    @UnsupportedAppUsage
    private static IWindowSession sWindowSession;
    
    @UnsupportedAppUsage
    public static IWindowSession getWindowSession() {
        synchronized (WindowManagerGlobal.class) {
            if (sWindowSession == null) {
                try {
                    ...
                    IWindowManager windowManager = getWindowManagerService();
                    sWindowSession = windowManager.openSession(
                            new IWindowSessionCallback.Stub() {
                                @Override
                                public void onAnimatorScaleChanged(float scale) {
                                    ValueAnimator.setDurationScale(scale);
                                }
                            });
                } catch (RemoteException e) {
                    throw e.rethrowFromSystemServer();
                }
            }
            return sWindowSession;
        }
    }
    ```
  
    > ※ WindowManagerService 是系统的窗口管理器，添加窗口必须要和它通信，并且它还负责各种事件的派发。
  
  - ###### 创建过程
  
    - [View 树在 Activity 中的创建过程](https://github.com/MemoryLimitExceeded/Android/blob/master/%E7%9F%A5%E8%AF%86%E7%82%B9/readme%E8%AF%A6%E7%BB%86%E5%86%85%E5%AE%B9/Android/UI/View%20%E4%BD%93%E7%B3%BB/View%20%E6%A0%91%E5%9C%A8%20Activity%20%E4%B8%AD%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.md)
  
      View 树的创建是由 Activity 的 onCreate() 中的 setContentView(Int) 发起的。
  
      > ※ setContentView() 有三个重载方法，效果都差不多，只是传入的参数不同。如果不清楚 Activity 的 onCreate() 是什么的话请参阅 Activity [概览](https://github.com/MemoryLimitExceeded/Android/blob/master/%E7%9F%A5%E8%AF%86%E7%82%B9/readme%E8%AF%A6%E7%BB%86%E5%86%85%E5%AE%B9/Android/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/Activity/%E6%A6%82%E8%A7%88.md)的生命周期那一节。
  
      Activity 调用 getWindow().setContentView() 在 Window 生成一个叫 DecorView 的实例，做为 View 树的根 View，它继承于  FrameLayout，而 FrameLayout 又继承于 ViewGroup。 随后将 Activity.setContentView(Int) 传入的布局文件 Id ，解析 xml 并将这个布局添加到内容中（contentParent）。
  
      ![](https://upload-images.jianshu.io/upload_images/7522223-68eef8da18fe8dce.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)
  
      > ※ 上图中的 Action Bar 在 Android 5.0 的时候被替换成了 Tool Bar，且只有 AppCompatActivity 有，其他都需要自己添加。不过可以调用 setTitle() 来用 TextView 显示标题。
  
      在 Activity 恢复到前台的时候 WindowManager 会调用 addView() 方法来进行 View 树的遍历，
  
      到最后将调用 ViewRootImpl.setView() 方法，开始遍历 View 树。
  
      ```java
      //--- SDK 29 ---
      //WindowManagerImpl
      @Override
      public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
          applyDefaultToken(params);
          mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);
      }
      //WindowManagerGlobal
      public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) {
          ...
          final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;
          ...
          ViewRootImpl root;
          View panelParentView = null;
          synchronized (mLock) {
              ...
              root = new ViewRootImpl(view.getContext(), display);
              view.setLayoutParams(wparams);
              mViews.add(view);
              mRoots.add(root);
              mParams.add(wparams);
              // do this last because it fires off messages to start doing things
              try {
                  root.setView(view, wparams, panelParentView);
              } catch (RuntimeException e) {
                  // BadTokenException or InvalidDisplayException, clean up.
                  if (index >= 0) {
                      removeViewLocked(index, true);
                  }
                  throw e;
              }
          }
      }
      ```
  
      > ※ WindowManagerImpl.addView() 是在 ActivityThread.handleResumeActivity() 方法中调用的，因为会涉及到 Activity 的启动流程，这里就不放出来了，不影响对 View 体系的分析。
  
    - View 树在 Dialog 中的创建过程
  
      它和 Activity 是一样的，都是调用 Window.setContentView()，来生成 View 树，由 Dialog.show() 发起。
  
  - ###### 遍历时机
  
    > ※ 详细链接
    >
  
    常见能发起遍历的有以下几种：
  
    ViewRootImpl.requestLayout()、ViewRootImpl.invalidate() 系列、ViewRootImpl.setLayoutParams()；
  
    ViewGroup.onDescendantInvalidated()、ViewGroup.onSetLayoutParams()；
  
    View.requestLayout()、View.damageInParent()、View.setLayoutParams()。
  
    - ViewRootImpl.requestLayout()
  
      通常是在 View 树根创建完成之后进行调用，即调用 ViewRootImpl.setView()：
  
      ```java
      //--- SDK 29 ---
      public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
          synchronized (this) {
              if (mView == null) {
                  mView = view;
      			...
                  // Schedule the first layout -before- adding to the window
                  // manager, to make sure we do the relayout before receiving
                  // any other events from the system.
                  requestLayout();
                  ...
              }
          }
      }
      @Override
      public void requestLayout() {
          if (!mHandlingLayoutInLayoutRequest) {
              checkThread();
              mLayoutRequested = true;
              scheduleTraversals();				//整个 View 树遍历的入口
          }
      }
      ```
  
      > ※ 这里强调一下，是先遍历 View 树再注册 Window。
  
    - View.requestLayout()
  
      ```java
      //--- SDK 29 ---
      protected ViewParent mParent;
      
      public void requestLayout() {
          ...
          if (mAttachInfo != null && mAttachInfo.mViewRequestingLayout == null) {
              // Only trigger request-during-layout logic if this is the view requesting it,
              // not the views in its parent hierarchy
              ViewRootImpl viewRoot = getViewRootImpl();
              if (viewRoot != null && viewRoot.isInLayout()) {
                  if (!viewRoot.requestLayoutDuringLayout(this)) {
                      return;
                  }
              }
              mAttachInfo.mViewRequestingLayout = this;
          }
          ...
          if (mParent != null && !mParent.isLayoutRequested()) {
              mParent.requestLayout();
          }
          ...
      }
      ```
  
      mParent 就是父布局的实例，ViewGroup 并没有重写 requestLayout() 和 isLayoutRequested()，DecorView 也没有。当 mParent.requestLayout() 一直被执行，那么就会爬到 DecorView 中，调用它自己的 requestLayout() 方法，那么它作为 View 树的根又会调用谁呢？先来看 DecorView 的 mParent 是哪来的 :
  
      ```java
      //--- SDK 29 ---
      //ViewRootImpl
      public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
          synchronized (this) {
              if (mView == null) {
                  mView = view;
      			...
                  // Schedule the first layout -before- adding to the window
                  // manager, to make sure we do the relayout before receiving
                  // any other events from the system.
                  requestLayout();
                  ...
                  view.assignParent(this);
                  ...
              }
          }
      }
      //View
      @UnsupportedAppUsage
      void assignParent(ViewParent parent) {
          if (mParent == null) {
              mParent = parent;
          } else if (parent == null) {
              mParent = null;
          } else {
              throw new RuntimeException("view " + this + " being added, but"
                      + " it already has a parent");
          }
      }
      ```
  
      这样就可以通过往上爬来调用 ViewRootImpl 的 requestLayout() 方法来启动遍历流程。
  
    - ViewRootImpl.invalidate() 系列
  
      ```java
      //--- SDK 29 ---
      @UnsupportedAppUsage
      void invalidate(){
          mDirty.set(0, 0, mWidth, mHeight);
          if (!mWillDrawSoon) {
              scheduleTraversals();
          }
      }
      private void invalidateRectOnScreen(Rect dirty) {
          ...
          if (!mWillDrawSoon && (intersected || mIsAnimating)) {
              scheduleTraversals();
          }
      }
      ```
      
      invalidate() 和 invalidateRectOnScreen() 都能调用到 scheduleTraversals()，也就是遍历的入口。
      
      > ※ invalidate() 一系列方法很多，这里就只放与之关系比较大的方法
      
    - ViewGroup.onDescendantInvalidated()
  
      ```java
      //--- SDK 29 ---
      @Override
      @CallSuper
      public void onDescendantInvalidated(@NonNull View child, @NonNull View target) {
          ...
          if (mParent != null) {
              mParent.onDescendantInvalidated(this, target);
          }
      }
      ```
      
      ViewGroup 没有重写 invalidate() 方法，虽然 onDescendantInvalidated() 方法没有直接调用 invalidate() 方法，但它调用父布局的 onDescendantInvalidated() 方法，显然最后会调用到 ViewRootImpl。
      
      ```java
      //--- SDK 29 ---
      //ViewRootImpl
      @Override
      public void onDescendantInvalidated(@NonNull View child, @NonNull View descendant) {
          if ((descendant.mPrivateFlags & PFLAG_DRAW_ANIMATION) != 0) {
              mIsAnimating = true;
          }
          invalidate();
      }
      ```
      
      最后通过 ViewRootImpl.invalidate() 启动遍历。
      
    - View.damageInParent()
  
      ```java
      //--- SDK 29 ---
      protected void damageInParent() {
          if (mParent != null && mAttachInfo != null) {
              mParent.onDescendantInvalidated(this, this);
          }
      }
      ```
      
      和 ViewGroup.onDescendantInvalidated() 差不多，能一直往树根爬，直到启动遍历。
      
    - ViewRootImpl.setLayoutParams()
  
      ```java
      //--- SDK 29 ---
      void setLayoutParams(WindowManager.LayoutParams attrs, boolean newView) {
          synchronized (this) {
              ...
              if (newView) {
                  mSoftInputMode = attrs.softInputMode;
                  requestLayout();
              }
              ...
              scheduleTraversals();
          }
      }
      ```
  
      > ※ 这里为什么会同时出现 requestLayout() 和 scheduleTraversals() 方法，目前不在这里做出分析。
  
    - ViewGroup.onSetLayoutParams()
  
      ```java
      //--- SDK 29 ---
      protected void onSetLayoutParams(View child, LayoutParams layoutParams) {
          requestLayout();			//View.requestLayout()
      }
      ```
  
    - View.setLayoutParams()
  
      ```java
      //--- SDK 29 ---
      public void setLayoutParams(ViewGroup.LayoutParams params) {
          ...
          if (mParent instanceof ViewGroup) {
              ((ViewGroup) mParent).onSetLayoutParams(this, params);
          }
          requestLayout();
      }
      ```
  
  - ###### 遍历流程
  
    目前知道遍历的入口 scheduleTraversals()，就从它开始：
  
    ```java
    //--- SDK 29 ---
    //ViewRootImpl
    @UnsupportedAppUsage
    void scheduleTraversals() {
        if (!mTraversalScheduled) {
            mTraversalScheduled = true;
            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
            mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
            if (!mUnbufferedInputDispatch) {
                scheduleConsumeBatchedInput();
            }
            notifyRendererOfFramePending();
            pokeDrawLockIfNeeded();
        }
    }
    ```
  
    注意这个 `mTraversalRunnable` 变量，它是 ViewRootImpl 内部类：
  
    ```java
    //--- SDK 29 ---
    final TraversalRunnable mTraversalRunnable = new TraversalRunnable();
    final class TraversalRunnable implements Runnable {
        @Override
        public void run() {
            doTraversal();
        }
    }
    void doTraversal() {
    if (mTraversalScheduled) {
        mTraversalScheduled = false;
        ...
        performTraversals();			//测量、布局、绘制三要素都在这个方法里面调用
    	...
    }
    ```
  
    看来 View 树的遍历是以 Runnable 的方式展现，并且它通过 Handler 机制运行： 
  
    ```java
    //--- SDK 29 ---
    //Choreographer
    private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) {
        ...
        synchronized (mLock) {
            final long now = SystemClock.uptimeMillis();
            final long dueTime = now + delayMillis;
            mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);
            if (dueTime <= now) {
                scheduleFrameLocked(now);
            } else {
                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);
                msg.arg1 = callbackType;
                msg.setAsynchronous(true);
                mHandler.sendMessageAtTime(msg, dueTime);
            }
        }
    }
    ```
  
    > ※ 不知道 Handler 机制无所谓，不影响下面的理解。
  
    View 的绘制流程为测量（Measure），布局（Layout），绘制（Draw），来看一下在 ViewRootImpl 的调用顺序：
  
    ```java
    //--- SDK 29 ---
    private void performTraversals() {
        ...
        if (layoutRequested) {
    	    ...
            // Ask host how big it wants to be
            windowSizeMayChange |= measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight);
        }
        ...
        if (mApplyInsetsRequested) {
            ...
            if (mLayoutRequested) {
                // Short-circuit catching a new layout request here, so
                // we don't need to go through two layout passes when things
                // change due to fitting system windows, which can happen a lot.
                windowSizeMayChange |= measureHierarchy(host, lp,
                        mView.getContext().getResources(),
                        desiredWindowWidth, desiredWindowHeight);
            }
        }
        ...
        if (mFirst || windowShouldResize || insetsChanged || viewVisibilityChanged || params != null || mForceNextWindowRelayout) {
            ...
    		if (!mStopped || mReportNextDraw) {
                ...
                if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()
                    || mHeight != host.getMeasuredHeight() || contentInsetsChanged ||
                            updatedConfiguration) {
                    ...
                    // Ask host how big it wants to be
                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
    				...
    				if (measureAgain) {
                        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
                    }
    				layoutRequested = true;
                }
            }
        } else {
            ...
        }
    	...
        if (didLayout) {
            performLayout(lp, mWidth, mHeight);
    		...
        }
    	...
        if (!cancelDraw) {
            ...
    		performDraw();
        } else {
            ...
        }
        mIsInTraversal = false;
    }
    ```
  
    - 测量
  
      View 树在测量阶段需要做的是把整棵 View 树上的 View 宽度和高度进行测量，从而确定每一个 View 的大小，performMeasure() 做为测量流程的入口，那么它势必会调用到 View 树中的测量入口：
  
      ```java
      //--- SDK 29 ---
      private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {
          if (mView == null) {
              return;
          }
          ...
          try {
              mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
          } finally {
              ...
          }
      }
      ```
  
      mView 就是整个 View 树的根，在 ViewRootImpl.setView() 中设置，measure() 方法只有 View 类当中才有：
  
      ```java
      //--- SDK 29 ---
      //View
      public final void measure(int widthMeasureSpec, int heightMeasureSpec) {
          ...
          if (forceLayout || needsLayout) {
              ...
              if (cacheIndex < 0 || sIgnoreMeasureCache) {
                  // measure ourselves, this should set the measured dimension flag back
                  onMeasure(widthMeasureSpec, heightMeasureSpec);
                  mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
              } else {
                  ...
              }
      		...
          }
      	...
      }
      protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
          setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
      }
      ```
  
      在 onMeasure() 中把测量好的宽度和高度确定下来，并调用 setMeasuredDimension() 来存储当前 View 测量好的数值。
  
      在这里需要说一下两个类：MeasureSpec 类和 LayoutParams 类，前者是 View 的内部类，后者是 ViewGroup 的内部类。
  
      MeasureSpec 类是个静态内部类，它的作用主要是封装从父布局传递到子布局的要求参数，类型为 Int，高 2 位是模式，低 30 位是具体长度数值。一共有 3 种模式：
  
      1. UNSPECIFIED（十进制：0，二进制：00）
  
         父布局没有对子布局施加要求，自己可以为所欲为。
  
      2. EXACTLY（十进制：1，二进制：01）
  
         父布局已经确定好子布局的大小。
  
      3. AT_MOST（十进制：2，二进制：10）
  
         子布局可以在父布局限定的大小内为所欲为。
  
      LayoutParams 类也是个静态内部类，它的作用主要是告诉父布局自己的布局参数。在 xml 写布局的时候常常会有什么 `layout_width`、`layout_height` 等，这些就是在 LayoutParams 中的参数。不过它有众多的子类，下面放一个例子：
  
      ```java
      //--- SDK 29 ---
      //ViewGroup
      public static class MarginLayoutParams extends ViewGroup.LayoutParams {
          
          @ViewDebug.ExportedProperty(category = "layout")
          @InspectableProperty(name = "layout_marginLeft")
          public int leftMargin;
      
          @ViewDebug.ExportedProperty(category = "layout")
          @InspectableProperty(name = "layout_marginTop")
          public int topMargin;
      
          @ViewDebug.ExportedProperty(category = "layout")
          @InspectableProperty(name = "layout_marginRight")
          public int rightMargin;
      
          @ViewDebug.ExportedProperty(category = "layout")
          @InspectableProperty(name = "layout_marginBottom")
          public int bottomMargin;
          ...
      }
      ```
  
      由于 ViewGroup 没有去遍历子布局的测量流程，这就需要我们自己去通过重写 onMeasure() 向里面实现功能。不过 Google 给我们写好了一个遍历子布局的测量流程，只是没有调用而已，留给开发者自己选择处理方法。
  
      ```java
      //--- SDK 29 ---
      //ViewGroup
      protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
          final int size = mChildrenCount;
          final View[] children = mChildren;
          for (int i = 0; i < size; ++i) {
              final View child = children[i];
              if ((child.mViewFlags & VISIBILITY_MASK) != GONE) {
                  measureChild(child, widthMeasureSpec, heightMeasureSpec);
              }
          }
      }
      protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) {
          final LayoutParams lp = child.getLayoutParams();
      	final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
                      mPaddingLeft + mPaddingRight, lp.width);
          final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
                      mPaddingTop + mPaddingBottom, lp.height);
      	child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
      }
      ```
  
      > ※ measure() 方法有 final 修饰了，不能重写，这里强调一下。
  
      实际上除 performTraversals() 能调用 performMeasure()，还有 measureHierarchy() 当中会调用。
  
      ```java
      //--- SDK 29 ---
      private boolean measureHierarchy(final View host, final WindowManager.LayoutParams lp, final Resources res, final int desiredWindowWidth, final int desiredWindowHeight) {
          int childWidthMeasureSpec;
          int childHeightMeasureSpec;
          boolean windowSizeMayChange = false;
          boolean goodMeasure = false;
          if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT) {
              final DisplayMetrics packageMetrics = res.getDisplayMetrics();
              res.getValue(com.android.internal.R.dimen.config_prefDialogWidth, mTmpValue, true);
              int baseSize = 0;
              if (mTmpValue.type == TypedValue.TYPE_DIMENSION) {
                  baseSize = (int)mTmpValue.getDimension(packageMetrics);
              }
              if (baseSize != 0 && desiredWindowWidth > baseSize) {
                  childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width);
                  childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);
                  performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
                  if ((host.getMeasuredWidthAndState()&View.MEASURED_STATE_TOO_SMALL) == 0) {
                      goodMeasure = true;
                  } else {
                      // Didn't fit in that size... try expanding a bit.
                      baseSize = (baseSize+desiredWindowWidth)/2;
                      childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width);
                      performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
                      if ((host.getMeasuredWidthAndState()&View.MEASURED_STATE_TOO_SMALL) == 0) {
                          goodMeasure = true;
                      }
                  }
              }
          }
      	if (!goodMeasure) {
              childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);
              childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);
              performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
              if (mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) {
                  windowSizeMayChange = true;
              }
          }
          return windowSizeMayChange;
      }
      ```
  
      正式测量之前都会进行预测量，因为可能一开始所给的整个布局大小并不适合整棵 View 树的大小，需要进行多次测量才能确定下来。而 measureHierarchy() 方法就是用来预测量的，都在 performMeasure() 方法之前。当窗口宽度为 `wrap_content` 时，进行两次测量，被称作测量协商，这里协商的就是这个宽度。一开始的取值是从资源文件获取的：
  
      ```xml
      <!-- SDK 29 -->
      <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
          <!-- see comment in values/config.xml -->
          <dimen name="config_prefDialogWidth">440dp</dimen>
      
          <!-- see comment in values/config.xml -->
          <integer name="config_longPressOnHomeBehavior">0</integer>
      
      </resources>
      ```
  
      如果两次测量协调也不能适合 View 树的大小，那么就直接给到最大，无论合不合适都没有多余的空间了。
  
    - 布局
  
  - ###### 在 View 树中添加和删除 View 
  
    > ※ [详细链接](https://github.com/MemoryLimitExceeded/Android/blob/master/%E7%9F%A5%E8%AF%86%E7%82%B9/readme%E8%AF%A6%E7%BB%86%E5%86%85%E5%AE%B9/Android/UI/View%20%E4%BD%93%E7%B3%BB/%E5%9C%A8%20View%20%E6%A0%91%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%20View.md)
  
    - 添加 View
    
      通过调用 ViewGroup.addView() 来实现把新创建的 View 添加到 View 树中。一共有 5 个调用方法：
    
      ```java
      public void addView(View child) {
          addView(child, -1);
      }
      public void addView(View child, int index) {
          ...
          addView(child, index, params);
      }
      public void addView(View child, int width, int height) {
          ...
          addView(child, -1, params);
      }
      public void addView(View child, LayoutParams params) {
          addView(child, -1, params);
      }
      public void addView(View child, int index, LayoutParams params) {
          ...
          requestLayout();
          invalidate(true);
          addViewInner(child, index, params, false);
      }
      ```
    
      前 4 个方法最终都会调用最后一个方法，其中第 4 个方法是实现了 ViewManager 接口的方法。ViewManager 就是专门添加和删除 View 的接口。
    
      ```java
      Interface to let you add and remove child views to an Activity（个人认为只要有类似 Activity 的 View 树就能使用这个接口，例如 Dialog）. To get an instance of this class, call {@link android.content.Context#getSystemService(java.lang.String) Context.getSystemService()}.
      ```
    
      然后真正添加到 View 树的是调用了 addViewInner()。
    
    - 删除 View
    
      有以下方法来实现把 View 从 View 树中删除：
    
      ```java
      public void removeView(View view) {
          if (removeViewInternal(view)) {
              requestLayout();
              invalidate(true);
          }
      }
      public void removeViewInLayout(View view) {
          removeViewInternal(view);
      }
      public void removeViewAt(int index) {
          removeViewInternal(index, getChildAt(index));
          requestLayout();
          invalidate(true);
      }
      public void removeViews(int start, int count) {
          removeViewsInternal(start, count);
          requestLayout();
          invalidate(true);
      }
      public void removeViewsInLayout(int start, int count) {
          removeViewsInternal(start, count);
      }
      public void removeAllViews() {
              removeAllViewsInLayout();
              requestLayout();
              invalidate(true);
          }
      protected void removeDetachedView(View child, boolean animate) {
      }
      ```
    
      以上都是通过调用 removeViewsInternal() 间接实现，它有三个重载方法：
    
      ```java
      private boolean removeViewInternal(View view) {
          final int index = indexOfChild(view);
          if (index >= 0) {
              removeViewInternal(index, view);
              return true;
          }
          return false;
      }
      private void removeViewInternal(int index, View view) {
          ...
      }
      private void removeViewsInternal(int start, int count) {
          ...
      }
      ```
    
      
    
    
    
    