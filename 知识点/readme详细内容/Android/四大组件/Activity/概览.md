### 概览

​	Activity 是 Android 四大组件之一，在四大组件当中作为 UI 界面和用户进行交互操作。移动端应用的入口不仅仅只是点击桌面图标，还可以通过其他应用来调用该应用的 Activity ，来与该应用进行交互。

​	Activity 类的另一个目的就是规范这种范式，Activity 充当了应用与用户交互的入口点。

> ※ 实际上 Activity 的 UI 实现是由 View 来实现的，Window 则做为 View 的容器，这里不过多提及。

#### 目录

- [如何使用](#如何使用)

- [生命周期](#生命周期)

- [状态变更和界面恢复](#状态变更和界面恢复)

- [任务和返回栈](#任务和返回栈)

  ------

  

- ##### 如何使用

  - 声明 Activity

    因为 Activity 是四大组件之一，我们需要在 AndroidManifest.xml 声明 Activity，并添加 activity 元素作为 application 元素的子元素。
    
    ```xml
    <manifest ... >
      <application ... >
          <activity android:name=".ExampleActivity" />
          ...
      </application ... >
      ...
  </manifest >
    ```
    
    > ※ 需要查看更多的 AndroidManifest.xml 声明内容，请点击 Google 官网[应用清单](https://developer.android.google.cn/guide/topics/manifest/manifest-intro)
    
  - 声明 Activity 权限

    权限不仅可以在 application 标签内声明，也可以在 activity 中声明。

    ```xml
    <activity android:name="...."
       android:permission=”...”
    />
    ```

    不过，只有当应用或者 Activity 在清单文件中包含即将启动的 Activity 的权限，才能对后者进行启动。

    放一下 Google 的示例：

    *例如，假设您的应用想要使用一个名为 SocialApp 的应用在社交媒体上分享文章，则 SocialApp 本身必须定义调用它的应用所需具备的权限：*

    ```xml
    <activity android:name="...."
       android:permission=”com.google.socialapp.permission.SHARE_POST”
    />
    ```

    *然后，为了能够调用 SocialApp，您的应用必须匹配 SocialApp 清单中设置的权限：*

    ```xml
    <manifest>
        <uses-permission android:name="com.google.socialapp.permission.SHARE_POST" />
    </manifest>  
    ```

  - 设置布局

    复写父类的 onCreate 方法，添加 Activity 的布局。

    ```kotlin
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }
    ```

    > ※ 对于如何编写布局这里也不做介绍，请参考百度众多的博客资源或者 Google [官方课程](https://www.udacity.com/course/android-basics-user-interface--ud834)

- ##### 生命周期

  Activity 有着自己的生命周期，当用户浏览、退出和返回应用时，应用中的 Activity  实例会在其生命周期的不同状态间转换。Activity 会提供许多回调，这些回调会让 Activity 知晓某个状态已经更改：系统正在创建、停止或恢复某个 Activity，或者正在销毁该 Activity 所在的进程。

  > ※ 如需了解有关处理生命周期的信息，请参阅 Google 官网[使用具有生命周期感知能力的组件处理生命周期](https://developer.android.google.cn/topic/libraries/architecture/lifecycle.html?hl=zh_cn)

  ![](https://developer.android.google.cn/guide/components/images/activity_lifecycle.png?hl=zh_cn)

  上图为 Activity 生命周期流程图。

  - onCreate()

    Activity 开始工作调用的方法，通过调用 setContentView(int) 解析 xml 获取布局，使用 findViewById(int) 获取控件实例来对控件进行初始化操作，开发者必须实现此回调。

    > ※ 与 Activity 生命周期相关联的所有具有生命周期感知能力的组件都将收到 ON_CREATE 事件。
    > （要想了解 ON_CREATE 事件是个什么东西，需要先了解 Lifecycle 类，可以先看一下生命周期部分所给的第一个链接网址，下同。）

  - onStart()

    Activity 即将进入前台要调用的方法，并且会对用户（部分）可见，进入前台要做的最后准备工作。

    > ※ 与 Activity 生命周期相关联的所有具有生命周期感知能力的组件都将收到 ON_START 事件。

  - onResume()

    Activity 即将要开始与用户进行交互要调用的方法。回调完成以后，该 Activity 将位于 Activity 堆栈顶端，并捕捉用户的输入。
    
    > ※ 与 Activity 生命周期相关联的所有具有生命周期感知能力的组件都将收到 ON_RESUME 事件。
    
  - onPause()

    当 Activity 处于失去焦点，就是无法对用户的交互进行处理的状态时，将会调用 onPause() 方法。不过仍可以接收后台任务的交互来对其进行处理和相应的展示。此时的 Activity 对于用户而言是可见或者部分可见的，例如点击一个按钮弹出一个对话框：

    ![](https://www.linuxidc.com/upload/2011_04/110425172347022.gif)

    对话框在 Activity 之上，Activity 是部分可见的，如果把对话框背景改为透明的，那么 Activity 整体就都可见了。

    > ※ 与 Activity 生命周期相关联的所有具有生命周期感知能力的组件都将收到 ON_PAUSE 事件。

  - onStop()

    当用户看不到 Activity 的时候，将会回调 onStop() 方法，这时的 Activity 处于“已停止”状态。

    > ※ 与 Activity 生命周期相关联的所有具有生命周期感知能力的组件都将收到 ON_STOP 事件。

  - onRestart()

    当 Activity 处于"已停止"状态且界面将要对用户部分可见或可见的时候，将会回调 onRestart() 方法。

  - onDestroy()

    在销毁 Activity 之前时，会调用 onDestroy() 方法。

    > ※ 与 Activity 生命周期相关联的所有具有生命周期感知能力的组件都将收到 ON_DESTROY 事件。

    值得注意的是，系统可能会因为内存不足的情况下去销毁还未销毁的 Activity，以便为用户提供更优质的交互体验。不过系统并不是直接终止 Activity，而是直接终止要回收的 Activity 所在的进程。并且不仅仅只包含 Activity，其他内容也会随着进程的销毁而销毁。系统销毁进程的可能性也取决于当时进程的状态，而进程的状态也收到 Activity 的状态影响。

    > 关于 Activity 状态对进程生命周期的影响这里就不提及，在对进程进行归纳的时候再去分析

- ##### 状态变更和界面恢复

  当部分配置发生变化的时候，Activity 将会销毁后重建，这样就会导致用户之前对 Activity 做的一些操作将失效，恢复到没有对其进行操作的状态。例如：竖屏转横屏的时候在文本框中已经输入的文字会消失。

  我们就需要在 Activity 销毁之前保存数据，在重建的时候再进行加载。onSaveInstanceState() 会在 Activity 销毁前调用，并且传入了 Bundle 来通过 key - value 的形式保存数据到磁盘。不过 Bundle 不适合保存数据较大的场景，因为它需要在主线程上进行序列化并占用系统进程内存。

  最后我们可以从 onCreate() 方法传入的 Bundle 读取数据，或者从 onRestoreInstanceState() 方法传入的 Bundle 读取数据（从 onRestoreInstanceState() 方法获取的 Bundle 不需要判空，因为如果 Bundle 为 null 是不会调用这个方法的）。

  事实上，只要不是用户按下返回键和程序某处调用了 finish()，系统就会调用 onSaveInstanceState() 方法。

  附上 Google 的使用方法：

  ```kotlin
  override fun onSaveInstanceState(outState: Bundle?) {
      // Save the user's current game state
      outState?.run {
          putInt(STATE_SCORE, currentScore)
          putInt(STATE_LEVEL, currentLevel)
      }
  
      // Always call the superclass so it can save the view hierarchy state
      super.onSaveInstanceState(outState)
  }
  
  companion object {
      val STATE_SCORE = "playerScore"
      val STATE_LEVEL = "playerLevel"
  }
  ```

  *如何在 onCreate() 中恢复某些状态数据：*

  ```kotlin
  override fun onCreate(savedInstanceState: Bundle?) {
      super.onCreate(savedInstanceState) // Always call the superclass first
  
      // Check whether we're recreating a previously destroyed instance
      if (savedInstanceState != null) {
          with(savedInstanceState) {
              // Restore value of members from saved state
              currentScore = getInt(STATE_SCORE)
              currentLevel = getInt(STATE_LEVEL)
          }
      } else {
          // Probably initialize members with default values for a new instance
      }
      // ...
  }
  ```

  *如何在 onRestoreInstanceState() 中恢复某些状态数据：*

  ```kotlin
  override fun onRestoreInstanceState(savedInstanceState: Bundle?) {
      // Always call the superclass so it can restore the view hierarchy
      super.onRestoreInstanceState(savedInstanceState)
  
      // Restore state members from saved instance
      savedInstanceState?.run {
          currentScore = getInt(STATE_SCORE)
          currentLevel = getInt(STATE_LEVEL)
      }
  }
  ```

- ##### 任务和返回栈

  Activity 的码放顺序是按照栈的先进先出来执行的，Activity 1 启动 Activity 2，Activity 2 在最上面和用户进行交互，当 Activity 2 退出后，Activity 1 变成栈顶，又开始和用户交互，Activity 这个就是返回栈。