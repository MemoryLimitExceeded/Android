动画分为两类：

**[Property Animation](https://developer.android.google.cn/guide/topics/graphics/prop-animation) (属性动画)**

可以定义一个随时间更改任何对象属性的动画，无论其是否绘制到屏幕上。

借助属性动画系统，您可以定义动画的以下特性：

- 时长：可以指定动画的时长。默认时长为 300 毫秒。
- 时间插值：可以指定如何根据动画的当前已播放时长来计算属性的值。
- 重复计数和行为：可以指定是否在某个时长结束后重复播放动画以及重复播放动画多少次。还可以指定是否要反向播放动画。如果将其设置为反向播放，则会先播放动画，然后反向播放动画，直到达到重复次数。
- Animator 集：可以将动画分成多个逻辑集，它们可以一起播放、按顺序播放或者在指定的延迟时间后播放。
- 帧刷新延迟：可以指定动画帧的刷新频率。默认设置为每 10 毫秒刷新一次，但应用刷新帧的速度最终取决于整个系统的繁忙程度以及系统为底层计时器提供服务的速度。

属性动画的工作原理

首先，让我们通过一个简单的示例来了解动画的工作原理。图 1 描绘了一个假设的对象，该对象的 x 属性（表示其在屏幕上的水平位置）添加了动画效果。动画时长设置为 40 毫秒，要移动的距离为 40 像素。该对象每隔 10 毫秒（这是默认的帧刷新频率）会水平移动 10 像素。在 40 毫秒时，动画停止，同时对象在水平位置 40 处停止。这是使用线性插值（表示对象以恒定速度移动）的动画示例。

![img](https://developer.android.google.cn/images/animation/animation-linear.png)

​																							图 1

您也可以指定动画使用非线性插值。图 2 展示了一个假设的对象，它在动画开始时加速，在动画结束前减速。该对象仍在 40 毫秒内移动了40 像素，但这种移动是非线性的。开始时，此动画加速移动到中间点，然后从中间点减速移动，直至动画结束。如图 2 所示，动画在开头和结尾移动的距离小于在中间移动的距离。

![img](https://developer.android.google.cn/images/animation/animation-nonlinear.png)

​																							图 2

我们来详细了解一下属性动画系统的重要组成部分将如何计算如上所示的动画。图 3 描绘了主类之间是如何相互协作的。

![img](https://developer.android.google.cn/images/animation/valueanimator.png)

​																							图 3

ValueAnimator 对象跟踪动画的时间，例如动画的已运行时长以及正在添加动画效果的属性的当前值。

ValueAnimator 包含 TimeInterpolator 和 TypeEvaluator；前者用于定义动画插值，后者用于定义如何计算正在添加动画效果的属性的值。例如，在图2中，所用的 TimeInterpolator 为 AccelerateDecelerateInterpolator，所用的 TypeEvaluator 为 IntEvaluator。

要开始动画，请创建一个 ValueAnimator，并为您想要添加动画效果的属性赋予起始值和结束值，以及动画时长。当您调用start()时，动画即会开始播放。在整个动画播放期间，ValueAnimator将基于动画时长和已播放时长计算已完成动画分数（在0和1之间）。已完成动画分数表示动画已完成时间的百分比，0 表示0%，1 表示100%。以图1 为例，在t = 10ms 处，已完成动画分数将为0.25，因为总时长t = 40ms。

在 ValueAnimator 计算完已完成动画分数后，它会调用当前设置的 TimeInterpolator 来计算插值分数。插值分数会将已完成动画分数映射为一个新分数，该分数会考虑已设置的时间插值。例如，在图2 中，由于动画缓慢加速，t = 10ms 时的插值分数（约0.15）小于已完成动画分数(0.25)。在图1 中，插值分数始终等于已完成动画分数。

计算插值分数后，ValueAnimator 会调用相应的 TypeEvaluator，以根据动画的插值分数、起始值和结束值来计算要添加动画效果的属性的值。例如，在图2中，t = 10 ms 时的插值分数为0.15，因此，此时属性的值为0.15 × (40 - 0)，即6。

**View Animation (视图动画)** ：

View Animation 还能细分为 Drawable Animation (帧动画) 和 Tween Animation (补间动画)。

[Drawable Animation](https://blog.csdn.net/carson_ho/article/details/73087488)：通过图片连播的形式来达到动画的效果，由于图片数量过多需要多多注意内存使用。

[Tween Animation](https://blog.csdn.net/carson_ho/article/details/72827747)：通过改变 View 对象的平移、缩放、旋转和透明度等各种渐进式变换完成动画效果。

属性动画与视图动画的区别

视图动画系统仅提供为 View 对象添加动画效果的功能，因此，如果您想为非对象添加动画效果，则必须实现自己的代码才能做到。视图动画系统也存在一些限制，因为它仅公开对象的部分方面来供您添加动画效果；例如，您可以对视图的缩放和旋转添加动画效果，但无法对背景颜色这样做。

视图动画系统的另一个缺点是它只会在绘制视图的位置进行修改，而不会修改实际的视图本身。例如，如果您为某个按钮添加了动画效果，使其可以在屏幕上移动，该按钮会正确绘制，但能够点击按钮的实际位置并不会更改，因此您必须通过实现自己的逻辑来处理此事件。

有了属性动画系统，您就可以完全摆脱这些束缚，还可以为任何对象（视图和非视图）的任何属性添加动画效果，并且实际修改的是对象本身。属性动画系统在执行动画方面也更为强健。概括地讲，您可以为要添加动画效果的属性（例如颜色、位置或大小）分配 Animator，还可以定义动画的各个方面，例如多个 Animator 的插值和同步。

不过，视图动画系统的设置需要的时间较短，需要编写的代码也较少。如果视图动画可以完成您需要执行的所有操作，或者现有代码已按照您需要的方式运行，则无需使用属性动画系统。在某些用例中，也可以针对不同的情况同时使用这两种动画系统。

